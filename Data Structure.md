## 分治、动规、贪心
1. 分治算法举例：例如归并排序，快速排序，计算斐波那契数列等
2. 动规算法举例：背包问题，最大子段和等。
3. 贪心算法举例：最小生成树，Dijkstra算法
### 分治与动态规划
**相同**：
- 分治和动态规划都是将**问题分解为子问题**，然后合并子问题的解得到原问题的解。

**不同**：
- **重叠子问题**：**分治法分解出的子问题是不重叠**的，因此分治法解决的问题不拥有重叠子问题，而**动态规划解决的问题拥有重叠子问题**。  
例如，归并排序和快速排序都是分别处理左序列和右序列，然后将左右序列的结果合并，过程中不出现重叠子问题，因此它们使用的都是分治法。
- **最优化问题**：分治法解决的问题不子定是最优化问题，而动态规划解决的问题一定是最优化问题。

### 贪心与动态规划
**相同**：
- 贪心和动态规划都要求原问题必须拥有**最优子结构**。

**不同**：
- 在动态规划中，每次选择通常**依赖于子问题**的解，因此我们通常以**自底向上**的方式求解动态规划（先小后大）；
- 在贪心算法中，我们总是做出**当前最优**，然后求解剩下的唯一的子问题，贪心算法在进行选择时可能依赖之前做出的选择，但**不依赖于将来的选择或子问题的解**。(**自顶向下**)

### 最小生成树用什么算法来实现？
最小生成树：整个拓扑图的所有路径之和最小
- **Kruskal算法-森林**  
每次找出加权值最低的边来构建最小生成树，而且规定：**每次添加的边不能造成生成树有回路**，直到找到N-1条边为止。
- **Prims算法-小树长大**  
在生成树集合邻接的边（集合V）中，加权值最小的边来建立生成树，直到找到N-1个边为止。

## 红黑树
### 红黑树性质
- 每个节点必须为红色或者黑色
- 根为黑色
- 树中的null叶子为黑色
- 若节点为红，则其两个孩子必为黑色
- 每个节点到其后代叶子的所有路径含有同样多的黑节点

### KMP算法
KMP算法的时间复杂度O(m+n)，而使用暴力匹配的时间复杂度则是O(mn)。  
kmp算法的核心是**计算最长相等前后缀**
- 子串：p1 p2 ... pk-1 = pj-k+1 ... pj-1
- 当匹配到pj失序，则直接将子串右移到pk在原来pj的位置（相当于这两个子串相等覆盖，**左侧子串相当于前缀，右侧子串相当于后缀**）
1. PM表：如ababa的部分匹配值为00123
- abab的最长相等前后缀为ab，值为2
- ababa的最长相等前后缀为aba，值为3
2. next表：PM表右移，得-10012，+1得01123（ababa 对应 12345），next表即为匹配失败时要跳转的序号

## vector
vector 是一段连续的线性内存空间。
### vector扩容机制
一般都是扩容两倍
- 完全弃用现有的内存空间，重新申请更大的内存空间；(**重新配置**)
- 将旧内存空间中的数据，按原有顺序移动到新的内存空间中；(**元素搬移**)
- 最后将旧的内存空间释放。( 这也就解释了，为什么 vector 容器在进行扩容后，与其相关的**指针、引用以及迭代器**可能会失效的原因。->**释放原内存**)

## 数据结构和算法的关系和区别是什么？
- 关系：  
数据结构是指**存储和组织数据的方式**，数据结构的设计可以影响算法的实现**效率和正确性**。  
算法是指**解决问题的具体步骤或过程**，可以**利用不同的数据结构**来实现，以便更高效地解决问题。  
- 区别：数据结构用于解决数据存储问题，而算法用于处理和分析数据

### 数据结构和算法是相关的
- 数组和排序算法：排序算法可以用于对数组进行排序，例如冒泡排序、快速排序、归并排序等。
- 树和搜索算法：搜索算法可以用于在树中查找特定节点，例如DFS、BFS等。
- 图和最短路径算法：最短路径算法可以用于查找图中两个节点之间的最短路径，例如Dijkstra算法、Floyd算法等。

### 算法是和数据结构无关的
- 字符串匹配算法：字符串匹配算法可以用于在一个字符串中查找另一个字符串的位置，例如暴力匹配、KMP算法。
- 动态规划算法：动态规划算法可以用于解决各种不同类型的问题，例如最长公共子序列、背包问题等。

### 树和图的区别
树是一种特殊的图
- 树：节点最多有一个父节点，但可以有多个子节点。
- 图：节点之间可以互相连接，形成任意复杂的结构。
