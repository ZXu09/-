### 操作系统引导
1. CPU加电
2. 执行JMP指令跳转BIOS
3. 执行BIOS
4. 硬件自检
5. 操作系统引导（加载**主引导记录MBR**（磁盘引导程序指示引导到哪个分区）->找活动分区即有操作系统的分区；活动分区加载**分区引导记录PBR**->启动管理器）

### 进程间通信ipc方式
1. **管道pipe**：管道是一种**半双工**的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指**父子进程**关系。
2. **消息队列MessageQueue（消息传递）**：消息队列是由**消息的链表**，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
3. **共享存储SharedMemory**：共享内存就是映射一段**能被其他进程所访问的内存**，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
4. **信号量Semaphore**：信号量是一个计数器，可以用来**控制多个进程对共享资源的访问**。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
5. **套接字Socket**：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于**不同机器间的进程通信**。

### 操作系统里两个线程访问同一块内存会产生什么问题
互斥
### 有什么解决措施？（实现临界区互斥）
- 软件方法：由**进程本身**负责实施互斥，不需要操作系统支持。增加一定的开销
- 硬件方法：使用专门的**机器指令**来实现互斥。可减少开销，但依赖于硬件，难以成为通用的解决办法
- **操作系统层**提供支解决互斥**信号量机制、管程机制和消息传递机制**

### 实现同步
1. **信号量实现让权等待**，而Peterson（软件互斥）、swap、TestAndSet（硬件互斥）不满足  
wait(S)P操作；signal(S)V操作
2. **管程**
- 名称、共享数据结构、对数据结构的操作、共享数据设置初值
- 条件变量：进入管程后的阻塞原因
- **信号量有值而条件变量无值**

### 死锁
**必要条件**
1. 资源**互斥**
2. 资源**不可被剥夺**
3. 进程**保持资源并请求**（不释放资源）-解决方法：一次申请所有所需资源
4. **循环等待**-解决方法：顺序资源分配法，只按照编号递增的顺序请求资源
- 死锁预防，申请资源时解决
- 死锁避免，银行家算法-系统安全状态
- 死锁检测和解除，资源分配图

### 分页
1. **分页作用及好处**：  
- 没有外部碎片
- 程序不必连续存放
- 易于扩展
2. 分页原因：  
有效地**管理内存**，提高**内存利用率**和保证**进程的安全性**（对于每个进程，操作系统会分配一个独立的页表来管理该进程的页面，不同的进程之间的内存空间被隔离开来）。
3. 与分段的关系
- 分页是由于**系统管理的需要**。段则是信息的逻辑单位，分段的目的是为了能更好地**满足用户的需要**。 
- **分页没有外部碎片，有内部碎片；分段有外部碎片没有内部碎片**  
两者都是**离散分配**方式、通过**地址映射机构来实现地址变换**

### 页面大小
- 页面过小->**页表太大**，占用内存，**增大地址转换开销**，降低页面换入/换出的效率（**缺页率高**）
- 页面过大->页内碎片增多，**降低内存的利用率**（**缺页率低**）

### 现代计算机的组成有哪些
cpu(运算器+控制器)、存储器、I/O

### 内存、cpu、外存连接
内存<-高速缓冲存储器(Cache)->CPU<-总线->外存

### 内核模式
- 切换  
用户调用操作系统服务（**系统调用**）或发生**中断**时，执行模式从用户模式切换到内核模式  
当系统服务返回或中断返回到用户进程时，执行模式从内核模式切换到用户模式  
- 为什么需要两种执行模式  
保护**操作系统和重要数据**不受用户干扰
- 如何知道当前系统处于哪个执行模式下?  
**程序状态字（PSW）** 中记录了当前系统所处的模式信息

### 进程切换
- 什么时候发生进程切换  
进程切换可以在操作系统从当前正在运行的进程中**获得控制权**的任何时刻发生。如**中断、陷阱、系统调用**等
- 进程切换，操作系统需要做什么  
1. **保存处理器的上下文环境**，包括PC和其他寄存器
2. 更新当前处于运行态的进程的**进程控制块(PCB)**，如把进程状态改变为另一状态（**就绪、阻塞、就绪/挂起或退出**，具体哪种状态取决于发生进程切换的事件）
3. 把上述进程的PCB**移到相应的队列**中（如就绪队列、事件i的阻塞队列等）
4. 从就绪队列中选择另一个进程执行（**进程调度**）
5. 更新所选择进程的**进程控制块(PCB)**，如把进程状态变为运行态
6. 更新**内存管理**的数据结构，如**基地址寄存器和界限寄存器（分段机制）**（易忘！）
7. **恢复**处理器在被选择进程最近一次切换出运行态的**上下文**：载⼊PC和其它寄存器最后一次保存的值

### 进程切换与模式切换
进程切换必然会存在模式切换（**只有在内核模式下才能实现进程调度**），但模式切换不一定会发生进程切换

### fork和exec的区别
- fork()系统调用被用于**创建一个新进程**。
- exec()系统调用被用于在**进程中启动新程序**。
- fork()创建了一个新的进程来**并行**执行不同的代码
- exec()在当前进程中**替换**代码和数据来运行一个新程序。

### 引入线程的好处
1. 易于**调度**
2. 提高**并发性**。通过线程可以方便有效地实现并发
3. **开销小**。创建线程比创建进程要快，所需的开销也更小
4. 有利于发挥**多处理器的功能**。通过创建多线程，每个线程都在一个处理器上运行，从而实现**应用程序的并行**，使每个处理器都得到充分运行。
### 进程与线程的区别？
1. **从属关系**：一个线程必定属于也只能属于一个进程；而一个进程可以拥有多个线程并且至少拥有一个线程。
2. **资源**：属于一个进程的所有线程共享该线程的所有资源，包括打开的文件、创建的Socket等。不同的进程互相独立。
3. **切换代价**：线程又被称为轻量级进程。进程有进程控制块，线程也有线程控制块。但线程控制块比进程控制块小得多。线程间切换代价小，进程间切换代价
4. **执行过程**：进程是程序的一次执行，线程可以理解为程序中一段程序片段的执行
5. **内存空间**：每个进程都有独立的内存空间，而线程共享其所属进程的内存空间。

### 中断过程
1. 关中断
2. 保存断点
3. 中断服务程序寻址  
以上为中断隐指令（cpu完成）
---
4. 保存现场
5. 开中断
6. 执行中断服务程序
7. 关中断
8. 恢复现场
9. 开中断，中断返回
